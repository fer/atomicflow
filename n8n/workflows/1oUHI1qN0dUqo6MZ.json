{"createdAt":"2025-05-12T20:23:01.586Z","updatedAt":"2025-05-12T21:36:36.423Z","id":"1oUHI1qN0dUqo6MZ","name":"My workflow backup credentials","active":false,"nodes":[{"parameters":{"rule":{"interval":[{"field":"hours","hoursInterval":12}]}},"name":"Schedule Trigger","type":"n8n-nodes-base.scheduleTrigger","typeVersion":1.2,"position":[-200,-60],"id":"0a029dfa-acd4-41b3-8c06-6a313aa5a9e6"},{"parameters":{"command":"npx n8n export:credentials --all --decrypted"},"name":"Export Credentials","type":"n8n-nodes-base.executeCommand","typeVersion":1,"position":[200,-60],"id":"1f8473de-176e-43f3-98b5-1159ef72c835"},{"parameters":{"jsCode":"// Function to beautify JSON\nfunction beautifyJson(jsonString) {\n  try {\n    // Parse the JSON string\n    const jsonObject = JSON.parse(jsonString);\n\n    // Format the JSON with indentation\n    return jsonObject; // Return the parsed object directly\n  } catch (error) {\n    // Return the error message if JSON is invalid\n    return `Invalid JSON: ${error.message}`;\n  }\n}\n\n// Retrieve the JSON object from the input data\nconst input = $input.all()[0].json;\n\n// Extract the JSON string from the stdout field\nconst jsonString = input.stdout.match(/\\[{.*}\\]/s);\n\n// Check if a valid JSON string is found\nif (!jsonString) {\n  return {\n    json: {\n      error: \"No valid JSON string found in stdout.\"\n    }\n  };\n}\n\n// Beautify the JSON\nconst beautifiedJson = beautifyJson(jsonString[0]);\n\n// Output the beautified JSON, ensuring each entry is in an object with a 'json' key\nconst output = beautifiedJson.map(entry => ({ json: entry }));\n\n// Return the output\nreturn output;\n"},"id":"5838159d-b626-4aeb-8924-ee3755db12ea","name":"JSON formatting","type":"n8n-nodes-base.code","position":[400,-60],"typeVersion":2},{"parameters":{"content":"Convert the file contents to JSON string","height":80},"id":"290d017b-5d96-4e9f-abbe-cdca16b8c125","name":"Sticky Note4","type":"n8n-nodes-base.stickyNote","position":[140,-280],"typeVersion":1},{"parameters":{"values":{"string":[{"name":"repo.owner","value":"fer"},{"name":"repo.name","value":"atomicflow"},{"name":"repo.path","value":"n8n/credentials/"}]},"options":{}},"id":"870b5129-d836-42fb-b880-ff1f1f3d10a2","name":"Globals","type":"n8n-nodes-base.set","position":[0,-60],"typeVersion":1},{"parameters":{"resource":"file","operation":"edit","owner":{"__rl":true,"value":"fer","mode":"name"},"repository":{"__rl":true,"value":"atomicflow","mode":"list","cachedResultName":"atomicflow","cachedResultUrl":"https://github.com/fer/atomicflow"},"filePath":"={{ $('Globals').item.json.repo.path}}all.json","binaryData":true,"commitMessage":"saving credentials to github"},"type":"n8n-nodes-base.github","typeVersion":1.1,"position":[840,-60],"id":"59940bc0-fe6f-4d5d-a3e3-21f94ebdc97d","name":"GitHub","webhookId":"91bb24d8-aefe-43c2-9829-264ed7564662","credentials":{"githubApi":{"id":"iGQWomWxVx4FvkiE","name":"GitHub account"}}},{"parameters":{"operation":"toJson","options":{}},"type":"n8n-nodes-base.convertToFile","typeVersion":1.1,"position":[620,-60],"id":"b1f85d6a-5cd3-4dab-9c10-fd1c2aec85a6","name":"Convert to File"}],"connections":{"Schedule Trigger":{"main":[[{"node":"Globals","type":"main","index":0}]]},"Export Credentials":{"main":[[{"node":"JSON formatting","type":"main","index":0}]]},"JSON formatting":{"main":[[{"node":"Convert to File","type":"main","index":0}]]},"Globals":{"main":[[{"node":"Export Credentials","type":"main","index":0}]]},"GitHub":{"main":[[]]},"Convert to File":{"main":[[{"node":"GitHub","type":"main","index":0}]]}},"settings":{"executionOrder":"v1"},"staticData":null,"meta":{"templateCredsSetupCompleted":true},"pinData":{},"versionId":"4dd584bb-ed5e-48cc-9023-2f75b837f902","triggerCount":0,"tags":[]}